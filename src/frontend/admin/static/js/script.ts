const websocket = new WebSocket(`ws://${window.location.host}/admin/ws`);

var spiderStatus: "success" | "error" | "processing" | "not_running" | "running" | "cancelled"
var alertLevel: "info" | "warning" | "error" | "critical"

interface Message {
    id: string
    element: HTMLDivElement
}

let activeMessages: Array<Message> = [];


interface AlertMessage {
    message: string;
    level: typeof alertLevel;
}

interface SpiderMessage {
    name: string;
    status: typeof spiderStatus;
    message: string;
}

interface BaseResponse<T = any> {
    signal: string;
    status: boolean;
    result?: T | null;
}

interface AlertResponse extends BaseResponse<AlertMessage> {}
interface SpiderResponse extends BaseResponse<SpiderMessage> {}

async function StartAllSpider() {
    try {
        await fetch("/admin/command", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                signal: "start",
                spider: "all"
            })
        });
    } catch (error) {
        console.error("Ошибка при отправке команды:", error);
    }
}

async function StopAllSpider(): Promise<void> {
    try {
        await fetch("/admin/command", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                signal: "stop",
                spider: "all"
            })
        });
    } catch (error) {
        console.error("Ошибка при отправке команды:", error);
    }
}

async function StartSpider(spiderName: string, page: number | null): Promise<void> {
    try {
        await fetch("/admin/command", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                signal: "start",
                spider: spiderName,
                page: page
            })
        });
    } catch (error) {
        console.error("Ошибка при отправке команды:", error);
    }
}

async function StopSpider(spiderName: string): Promise<void> {
    try {
        await fetch("/admin/command", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                signal: "stop",
                spider: spiderName
            })
        });
    } catch (error) {
        console.error("Ошибка при отправке команды:", error);
    }
}

function UpdateSpider(spider: SpiderMessage): void {
    let spiderFound = false;

    const spiderBox = document.getElementById("Spiders");
    if (!spiderBox) {
        console.warn("Элемент 'Spiders' не найден.");
        return;
    }

    // Удаляем заглушку <strong>, если она есть
    const strong = spiderBox.querySelector("strong");
    strong?.remove();

    const spiderName = spider.name;
    const spiderStatus = spider.status;
    const spiderMessage = spider.message;

    const spiderChilds = spiderBox.querySelectorAll('.spider');

    // Поиск существующей карточки паука
    for (let index = 0; index < spiderChilds.length; index++) {
        const element = spiderChilds[index];
        const h1 = element.querySelector("h1");
        const p = element.querySelector("p");
        const b = element.querySelector("b");

        if (h1 && h1.innerText === spiderName) {
            spiderFound = true;
            // Создаём новую карточку взамен старой (чтобы не копить обработчики)
            if (p && p.innerText != spiderStatus || b && b.innerText != spiderMessage) {
                const newDiv = document.createElement("div");
                newDiv.className = "spider";

                // Заголовок с именем паука
                const newH1 = document.createElement("h1");
                newH1.textContent = spiderName;
                newDiv.appendChild(newH1);

                // Статус
                const newP = document.createElement("p");
                newP.textContent = spiderStatus;
                newDiv.appendChild(newP);

                newP.style.color = getColor(spiderStatus);

                // Сообщение
                const newB = document.createElement("b");
                newB.textContent = spiderMessage;
                newDiv.appendChild(newB);

                // Поле для номера страницы (может быть полезно)
                const pageInput = document.createElement("input");
                pageInput.setAttribute("type", "number");
                newDiv.appendChild(pageInput);

                // Кнопка с data-атрибутом (без обработчика)
                const newButton = document.createElement("button");
                newButton.textContent = spiderStatus === "not_running" ? "Начать парсинг" : "Остановить парсинг";
                newButton.dataset.spider = spiderName;
                newDiv.appendChild(newButton);

                // Заменяем старую карточку новой
                element.parentNode?.replaceChild(newDiv, element);
                break;
            }
        }
    }

    // Если паук не найден, создаём новую карточку
    if (!spiderFound) {
        const divSpider = document.createElement("div");
        divSpider.className = "spider";

        const h1 = document.createElement("h1");
        h1.textContent = spiderName;
        divSpider.appendChild(h1);

        const p = document.createElement("p");
        p.style.color = getColor(spiderStatus);
        p.textContent = spiderStatus;
        divSpider.appendChild(p);

        const b = document.createElement("b");
        b.textContent = spiderMessage;
        divSpider.appendChild(b);

        const page = document.createElement("input");
        page.setAttribute("type", "number");
        divSpider.appendChild(page);

        const button = document.createElement("button");
        button.textContent = spiderStatus === "not_running" ? "Начать парсинг" : "Остановить парсинг";
        button.dataset.spider = spiderName;   // сохраняем имя паука
        divSpider.appendChild(button);

        spiderBox.appendChild(divSpider);
    }
}

function getColor(status: typeof spiderStatus): string {
    switch(status) {
        case "error":
            return "#F44336"; // Яркий красный - опасность, ошибка
        case "cancelled":
            return "#FF9800"; // Оранжевый - отмена, предупреждение
        case "not_running":
            return "#9E9E9E"; // Серый - неактивно, ожидание
        case "success":
            return "#4CAF50"; // Зеленый - успех, готово
        case "running":
            return "#2196F3"; // Синий - в процессе, активно
        case "processing":
            return "#FFC107"; // Янтарный - обработка, внимание
        default:
            return "";
    }
}

function OnAlert(message: string, level: typeof alertLevel): void {
    const messagesContainer = document.querySelector('.messages');
    if (!messagesContainer) {
        console.error('Контейнер для сообщений не найден!');
        return;
    }

    const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    const messageElement = document.createElement('div');
    messageElement.id = messageId;
    messageElement.className = `message ${level}`;
    messageElement.innerHTML = `<h1><span>${message}</span></h1>`;
    
    messagesContainer.appendChild(messageElement);
    
    activeMessages.push({
        id: messageId,
        element: messageElement
    });

    setTimeout(() => {
        const msgIndex = activeMessages.findIndex(msg => msg.id === messageId);
        if (msgIndex !== -1) {
            if (activeMessages[msgIndex].element && activeMessages[msgIndex].element.parentNode) {
                activeMessages[msgIndex].element.remove();
            }
            activeMessages.splice(msgIndex, 1);
        }
    }, 4000);

}

// --- Обработчик кликов через делегирование ---
document.addEventListener("DOMContentLoaded", () => {
    const spiderBox = document.getElementById("Spiders");
    if (spiderBox) {
        spiderBox.addEventListener("click", (event) => {
            const target = event.target as HTMLElement;
            const button = target.closest("button");
            if (!button) return; // клик не по кнопке

            const spiderDiv = button.closest(".spider");
            if (!spiderDiv) return; // кнопка не внутри карточки паука

            const spiderName = button.dataset.spider;
            const spiderInput = spiderDiv.querySelector("input") as HTMLInputElement | null;
            
            var intPage: number | null = null
            var stringPage: string | undefined = spiderInput?.value;
            if (stringPage) {
                intPage = parseInt(stringPage);
            }            

            if (!spiderName) return; // нет data-атрибута

            // Определяем действие по тексту кнопки
            if (button.textContent?.includes("Начать")) {
                StartSpider(spiderName, intPage);
            } else {
                StopSpider(spiderName);
            }
        });
    }
});

websocket.onmessage = function (event: MessageEvent): void {
    let answer: BaseResponse = JSON.parse(event.data);
    console.log(answer);

    if (answer.signal === "alert") {
        let result = answer.result as AlertMessage;
        OnAlert(result.message, result.level);
    } else if (answer.signal === "status") {
        let result = answer.result as Array<SpiderMessage>;
        for (const element of result) {
            UpdateSpider(element);
        }
    }
};